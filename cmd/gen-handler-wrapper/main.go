package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

const module = "github.com/nvvu/goast-demo"

var filename = "handler_wrapper.gen.go"

func main() {
	flag.Parse()

	pkgs, err := packages.Load(&packages.Config{
		Mode: packages.LoadAllSyntax,
	}, flag.Args()...)

	if err != nil {
		log.Fatal(err)
	}

	if packages.PrintErrors(pkgs) > 0 {
		log.Fatal("Errors in pkgs")
	}

	packages.Visit(pkgs, func(p *packages.Package) bool {
		if !strings.HasPrefix(p.PkgPath, module) {
			return false
		}

		if _err := visitPackage(p); _err != nil {
			err = _err
			return false
		}

		return true
	}, nil)

	if err != nil {
		fmt.Println(err)
	}
}

func visitPackage(p *packages.Package) error {
	filePath := filepath.Dir(p.GoFiles[0]) + "/" + filename

	// delete file
	os.Remove(filePath)

	// fmt.Println(p.PkgPath, p.GoFiles)

	// if len(p.GoFiles) > 0 {
	// 	filename = filepath.Dir(p.GoFiles[0]) + "/jo.gen.go"
	// 	fmt.Println(filename)
	// }

	// fmt.Println(p.Name)

	var buf bytes.Buffer

	_, _ = fmt.Fprintf(&buf, "// Code generated by jo. DO NOT EDIT. \n")
	_, _ = fmt.Fprintf(&buf, "package %s\n", p.Name)
	_, _ = fmt.Fprintf(&buf, "%s\n", importText)

	checkFunc := func(node *ast.FuncDecl) {
		// fmt.Printf("%s: %s_Hdl\n", node.Name, node.Name)

		reqField := node.Type.Params.List[1]
		st, _ := reqField.Type.(*ast.StarExpr)
		i, _ := st.X.(*ast.Ident)
		reqName := i.Name

		respField := node.Type.Results.List[0]
		st1, _ := respField.Type.(*ast.StarExpr)
		j, _ := st1.X.(*ast.Ident)
		respName := j.Name

		_ = tpl.Execute(&buf, map[string]interface{}{
			"Name":         node.Name,
			"RequestName":  reqName,
			"ResponseName": respName,
		})

		fmt.Println(buf.String())
	}

	for _, f := range p.Syntax {
		// inspect file
		ast.Inspect(f, func(node ast.Node) bool {
			// process if node is function
			switch node := node.(type) {
			case *ast.FuncDecl:
				if node.Doc != nil && len(node.Doc.List) > 0 {
					for _, line := range node.Doc.List {
						// fmt.Println(">", line.Text)
						if strings.HasPrefix("// +hdl", line.Text) {
							checkFunc(node)
						}
					}
				}
			}

			return true
		})
	}

	file, _ := os.Create(filePath)
	defer file.Close()

	buf.WriteTo(file)

	return nil
}

var tpl = template.Must(template.New("tpl").Parse(funcText))

const importText = `
import (
	"encoding/json"
	"io/ioutil"
	"log"
	"net/http"
)`

const funcText = `
func {{.Name}}_hdl(w http.ResponseWriter, r *http.Request) {
	req := &{{.RequestName}}{}
	resp := &{{.ResponseName}}{}

	reqData, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Fatal(err)
	}

	if err = json.Unmarshal(reqData, req); err != nil {
		log.Fatal(err)
	}

	resp, err = {{.Name}}(r.Context(), req)
	if err != nil {
		log.Println(err)
	}

	b, err := json.Marshal(resp)

	if err != nil {
		log.Fatal(err)
	}

	_, _ = w.Write(b)
}
`
